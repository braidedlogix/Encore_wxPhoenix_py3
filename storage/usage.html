

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Usage &mdash; Encore 0.4.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/enthought_doc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../_static/et.ico"/>
    <link rel="top" title="Encore 0.4.0 documentation" href="../index.html" />
    <link rel="up" title="Storage" href="index.html" />
    <link rel="next" title="Key-Value Store API" href="abstract_store.html" />
    <link rel="prev" title="Key-Value Store Concepts" href="concepts.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="abstract_store.html" title="Key-Value Store API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="concepts.html" title="Key-Value Store Concepts"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">Encore 0.4.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Storage</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/e-logo-rev.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Usage</a><ul>
<li><a class="reference internal" href="#creating-and-connecting">Creating and Connecting</a></li>
<li><a class="reference internal" href="#reading">Reading</a></li>
<li><a class="reference internal" href="#querying">Querying</a></li>
<li><a class="reference internal" href="#writing">Writing</a></li>
<li><a class="reference internal" href="#transactions">Transactions</a></li>
<li><a class="reference internal" href="#the-multi-methods">The &#8220;Multi&#8221; Methods</a></li>
<li><a class="reference internal" href="#events">Events</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="concepts.html"
                        title="previous chapter">Key-Value Store Concepts</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="abstract_store.html"
                        title="next chapter">Key-Value Store API</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/storage/usage.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Permalink to this headline">¶</a></h1>
<p>The key-value store API gives a common API that can be used with a variety of
different backends to provide a consistent interface for storage.  If used
correctly you can swap out the backend used with little or no modification of
the user code.</p>
<div class="section" id="creating-and-connecting">
<h2>Creating and Connecting<a class="headerlink" href="#creating-and-connecting" title="Permalink to this headline">¶</a></h2>
<p>Before you use a store, you need to create an instance of the appropriate type,
and then connect to it, possibly authenticating if that is required.  For
example, the following connects to a read-only remote store via HTTP, using
HTTP Authentication:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">encore.events.api</span> <span class="kn">import</span> <span class="n">EventManager</span>
<span class="kn">from</span> <span class="nn">encore.storage.static_url_store</span> <span class="kn">import</span> <span class="n">StaticURLStore</span>

<span class="n">event_manager</span> <span class="o">=</span> <span class="n">EventManager</span><span class="p">()</span>
<span class="n">store</span> <span class="o">=</span> <span class="n">StaticURLStore</span><span class="p">(</span><span class="n">event_manager</span><span class="p">,</span> <span class="s">&#39;http://localhost:8080/&#39;</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="s">&#39;index.json&#39;</span><span class="p">)</span>
<span class="n">store</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">credentials</span><span class="o">=</span><span class="p">{</span><span class="s">&#39;username&#39;</span><span class="p">:</span> <span class="s">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">password</span><span class="p">:</span> <span class="s">&#39;Open Sesame&#39;</span><span class="p">})</span>
</pre></div>
</div>
<p>At this point the store is ready to use.  You can check to see whether the store
has connected using the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.is_connected" title="encore.storage.abstract_store.AbstractReadOnlyStore.is_connected"><tt class="xref py py-meth docutils literal"><span class="pre">is_connected()</span></tt></a> method.  When you are finished
with a store, you should call its <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.disconnect" title="encore.storage.abstract_store.AbstractReadOnlyStore.disconnect"><tt class="xref py py-meth docutils literal"><span class="pre">disconnect()</span></tt></a> method to allow it to
cleanly release any resources it may be using, such as database connections.</p>
</div>
<div class="section" id="reading">
<h2>Reading<a class="headerlink" href="#reading" title="Permalink to this headline">¶</a></h2>
<p>To read from a store, you use one of the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get" title="encore.storage.abstract_store.AbstractReadOnlyStore.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>
methods:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">value</span> <span class="o">=</span> <span class="n">store</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;my_document&#39;</span><span class="p">)</span>
<span class="n">datastream</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">data</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">metadata</span>
</pre></div>
</div>
<p>In this case datastream is a file-like object that streams bytes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">data</span> <span class="o">=</span> <span class="n">datastream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="k">print</span> <span class="n">data</span>
</pre></div>
</div>
<p>More likely you will have used some sort of serialization format like XML, JSON
or YAML to store your data in the document, so instead you can do:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">json</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datastream</span><span class="p">)</span>
</pre></div>
</div>
<p>If the data is raw bytes to store into a numpy array, you can do something like
this:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">datastream</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int32</span>
<span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">/</span><span class="n">dtype</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
<span class="n">arr</span><span class="o">.</span><span class="n">data</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">data</span>
</pre></div>
</div>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt> method supports buffered reads if your data is larger than
would comfortably fit into memory.</p>
<p>The metadata stores auxilliary information about the data that is stored in the
key.  It is a dictionary of reasonably serializable values (frequently it will
serialize to JSON or similar format):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">print</span> <span class="s">&#39;Document title:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;title&#39;</span><span class="p">]</span>
<span class="k">print</span> <span class="s">&#39;Document author:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;author&#39;</span><span class="p">]</span>
<span class="k">print</span> <span class="s">&#39;Document encoding:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;encoding&#39;</span><span class="p">]</span>

<span class="c"># checksum</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="k">assert</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha1</span><span class="p">(</span><span class="n">document</span><span class="o">.</span><span class="n">read</span><span class="p">())</span><span class="o">.</span><span class="n">digest</span><span class="p">()</span> <span class="o">==</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;sha1&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>What metadata is stored is completely dependent on the use-case for the key-value
store: the key-value store makes no assumptions.</p>
<p>If you try to read a key which doe not exist, then the store will raise a KeyError.
If you want to see whether or not a particular key is populated, you can use the
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.exists" title="encore.storage.abstract_store.AbstractReadOnlyStore.exists"><tt class="xref py py-meth docutils literal"><span class="pre">exists()</span></tt></a> method.</p>
<p>Frequently you will only be interested in the data or the metadata, not both.
For these cases there are methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get_data" title="encore.storage.abstract_store.AbstractReadOnlyStore.get_data"><tt class="xref py py-meth docutils literal"><span class="pre">get_data()</span></tt></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get_metadata" title="encore.storage.abstract_store.AbstractReadOnlyStore.get_metadata"><tt class="xref py py-meth docutils literal"><span class="pre">get_metadata()</span></tt></a>
which return the appropriate entities.  For metadata, if you are only interested
in the values of some of the dictionary keys, you can supply an additional argument
<tt class="docutils literal"><span class="pre">select</span></tt> which will restrict the returned keys to this subset of all the keys:</p>
<blockquote>
<div>author_info = store.get_metadata(&#8216;document&#8217;, select=[&#8216;author&#8217;, &#8216;organization&#8217;])</div></blockquote>
<p>It is very common that you either want to extract the stream of bytes from a value
into a Python bytes object (ie. a string in Python 2, as opposed to unicode) or
into a file on the local filesystem.  Two utility methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_file" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_file"><tt class="xref py py-meth docutils literal"><span class="pre">to_file()</span></tt></a>
and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_bytes" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_bytes"><tt class="xref py py-meth docutils literal"><span class="pre">to_bytes()</span></tt></a> are provided which perform these operations.  If the
data source is larger than will comfortably fit into memory (particularly for
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.to_file" title="encore.storage.abstract_store.AbstractReadOnlyStore.to_file"><tt class="xref py py-meth docutils literal"><span class="pre">to_file()</span></tt></a>) you can supply an optional buffer size:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s">&#39;document&#39;</span><span class="p">,</span> <span class="s">&#39;local_document.txt&#39;</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">=</span><span class="mi">8096</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="querying">
<h2>Querying<a class="headerlink" href="#querying" title="Permalink to this headline">¶</a></h2>
<p>Frequently you want to find keys whose metadata match certain criteria.  The
key-value store API gives a simple query mechanism that permits this sort of
matching:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">metadata</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="s">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">organization</span><span class="o">=</span><span class="s">&#39;40 Thieves&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">key</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="p">[</span><span class="s">&#39;title&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>This will print the key and title of all documents which have an <tt class="docutils literal"><span class="pre">author</span></tt> key
with value <tt class="docutils literal"><span class="pre">'alibaba'</span></tt> and an <tt class="docutils literal"><span class="pre">organization</span></tt> key with value <tt class="docutils literal"><span class="pre">'40</span> <span class="pre">Thieves'</span></tt>.
The current API only permits querying for exact matches and matching all of the
query terms.  More complex queries would need to be performed on an ad-hoc basis
on top of this API.</p>
<p>If all the user is concerned with is which keys match, there is an alternative
method <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.query_keys" title="encore.storage.abstract_store.AbstractReadOnlyStore.query_keys"><tt class="xref py py-meth docutils literal"><span class="pre">query_keys()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query_keys</span><span class="p">(</span><span class="n">author</span><span class="o">=</span><span class="s">&#39;alibaba&#39;</span><span class="p">,</span> <span class="n">organization</span><span class="o">=</span><span class="s">&#39;40 Thieves&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">key</span>
</pre></div>
</div>
<p>To iterate over all the keys in a store, you can simply call <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.query_keys" title="encore.storage.abstract_store.AbstractReadOnlyStore.query_keys"><tt class="xref py py-meth docutils literal"><span class="pre">query_keys()</span></tt></a>
with no arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">query_keys</span><span class="p">():</span>
    <span class="k">print</span> <span class="n">key</span>
</pre></div>
</div>
<p>Finally, as a useful utility, you can use glob-style matching on the keys using
the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.glob" title="encore.storage.abstract_store.AbstractReadOnlyStore.glob"><tt class="xref py py-meth docutils literal"><span class="pre">glob()</span></tt></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">store</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">&#39;*.jpg&#39;</span><span class="p">):</span>
    <span class="k">print</span> <span class="n">key</span>
</pre></div>
</div>
</div>
<div class="section" id="writing">
<h2>Writing<a class="headerlink" href="#writing" title="Permalink to this headline">¶</a></h2>
<p>Most, but not all, stores also allow you to write data to keys.  The basic method
is <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set" title="encore.storage.abstract_store.AbstractStore.set"><tt class="xref py py-meth docutils literal"><span class="pre">set()</span></tt></a> which is the inverse of <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.get" title="encore.storage.abstract_store.AbstractReadOnlyStore.get"><tt class="xref py py-meth docutils literal"><span class="pre">get()</span></tt></a>.  It expects a
file-like object with a <tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt> method that can do buffering, and a
dictionary of metadata as arguments:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">cStringIO</span> <span class="kn">import</span> <span class="n">StringIO</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="s">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;title&#39;</span><span class="p">:</span> <span class="s">&quot;Greeting&quot;</span><span class="p">,</span> <span class="s">&#39;author&#39;</span><span class="p">:</span> <span class="s">&#39;alibaba&#39;</span><span class="p">}</span>
<span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">metadata</span><span class="p">))</span>
</pre></div>
</div>
<p>As with reading, there are methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set_data" title="encore.storage.abstract_store.AbstractStore.set_data"><tt class="xref py py-meth docutils literal"><span class="pre">set_data()</span></tt></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.set_metadata" title="encore.storage.abstract_store.AbstractStore.set_metadata"><tt class="xref py py-meth docutils literal"><span class="pre">set_metadata()</span></tt></a>
that permit you to set just one of the two parts of the value, and there are
utility methods <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.from_bytes" title="encore.storage.abstract_store.AbstractStore.from_bytes"><tt class="xref py py-meth docutils literal"><span class="pre">from_bytes()</span></tt></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.from_file" title="encore.storage.abstract_store.AbstractStore.from_file"><tt class="xref py py-meth docutils literal"><span class="pre">from_file()</span></tt></a> that populate
the data of a key from either a byte string or a binary file.  The latter two
methods do not set any metadata: that must be done manually if needed.</p>
<p>If you want to add to the metadata without overwriting it, there is a convenience
method <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.update_metadata" title="encore.storage.abstract_store.AbstractStore.update_metadata"><tt class="xref py py-meth docutils literal"><span class="pre">update_metadata()</span></tt></a> method that will update the
metadata dictionary in mych the same way that the standard Python dictionary&#8217;s
<tt class="docutils literal"><span class="pre">update</span></tt> method works.</p>
<p>You can delete a key with the <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.delete" title="encore.storage.abstract_store.AbstractStore.delete"><tt class="xref py py-meth docutils literal"><span class="pre">delete()</span></tt></a> method:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">store</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="s">&#39;hello&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="transactions">
<h2>Transactions<a class="headerlink" href="#transactions" title="Permalink to this headline">¶</a></h2>
<p>The key-value store API does not assume that the underlying storage mechanism
has a notion of transactions, but if it does then it can be supported by the
key-value store.  Transactions are handled by context managers and the with
statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s">&#39;Setting some values&#39;</span><span class="p">):</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;key1&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">metadata1</span><span class="p">))</span>
    <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;key2&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">data2</span><span class="p">,</span> <span class="n">metadata2</span><span class="p">))</span>
</pre></div>
</div>
<p>If any exception were to occur in the with statement, the context manager will
ensure that the transaction gets rolled back.  Otherwise the transaction will
be committed when the with statement finishes.</p>
<p>Transactions are re-entrant, so it is safe to do the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">add_keypair</span><span class="p">(</span><span class="n">keypair</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s">&#39;Adding keypair&#39;</span><span class="p">):</span>
        <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">key1</span><span class="p">,</span> <span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">data1</span><span class="p">,</span> <span class="n">keypair</span><span class="o">.</span><span class="n">metadata1</span><span class="p">))</span>
        <span class="n">store</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">key2</span><span class="p">,</span> <span class="p">(</span><span class="n">keypair</span><span class="o">.</span><span class="n">data2</span><span class="p">,</span> <span class="n">keypair</span><span class="o">.</span><span class="n">metadata2</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">add_many_keypairs</span><span class="p">(</span><span class="n">keypairs</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">store</span><span class="o">.</span><span class="n">transaction</span><span class="p">(</span><span class="s">&#39;Adding many keypairs&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">keypair</span> <span class="ow">in</span> <span class="n">keypairs</span><span class="p">:</span>
            <span class="n">add_keypair</span><span class="p">(</span><span class="n">keypair</span><span class="p">)</span>
</pre></div>
</div>
<p>The transaction in the function is effectively ignored, with only the outermost
transaction applying.</p>
</div>
<div class="section" id="the-multi-methods">
<h2>The &#8220;Multi&#8221; Methods<a class="headerlink" href="#the-multi-methods" title="Permalink to this headline">¶</a></h2>
<p>For convenience there are a collection of methods prefixed by &#8220;multi&#8221;, such as
<a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractReadOnlyStore.multiget" title="encore.storage.abstract_store.AbstractReadOnlyStore.multiget"><tt class="xref py py-meth docutils literal"><span class="pre">multiget()</span></tt></a> and <a class="reference internal" href="abstract_store.html#encore.storage.abstract_store.AbstractStore.multiset_data" title="encore.storage.abstract_store.AbstractStore.multiset_data"><tt class="xref py py-meth docutils literal"><span class="pre">multiset_data()</span></tt></a>,
which perform the specified operations on a collection of keys at once.  If
transactions are available, then these will be done as a single transaction.</p>
</div>
<div class="section" id="events">
<h2>Events<a class="headerlink" href="#events" title="Permalink to this headline">¶</a></h2>
<p>The various stores use the Encore event system, which is why the stores must
be supplied with a reference to an EventManager instance.  The events which are
emitted are referenced in the documentation for each method.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="abstract_store.html" title="Key-Value Store API"
             >next</a> |</li>
        <li class="right" >
          <a href="concepts.html" title="Key-Value Store Concepts"
             >previous</a> |</li>
        <li><a href="../index.html">Encore 0.4.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Storage</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011-2013, Enthought, Inc..
      Last updated on Jul 24, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>